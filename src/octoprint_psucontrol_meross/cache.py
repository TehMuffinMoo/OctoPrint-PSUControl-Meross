import hashlib
import inspect
import logging
import os
import shelve
import threading
import time

from pathlib import Path
from typing import Callable

from .exc import CacheGetError, MerossCacheError

logger = logging.getLogger(__name__)


class MerossCache:
    """Wrapper around shelf's cache file."""

    _shelve: dict = None  # shelve cache

    def __init__(self, cache_file: Path, logger):
        self._logger = logger
        self.mutex = threading.Lock()
        try:
            self._shelve = shelve.open(os.fspath(cache_file))
        except Exception:
            self._logger.exception(f"Error while opening {cache_file!r} cache")
            if cache_file.exists():
                os.unlink(cache_file)
            # Attempt one more time
            self._shelve = shelve.open(os.fspath(cache_file))
        else:
            self._logger.debug(f"Sucessfully opened {cache_file!r} cache.")
        if self._shelve is None:
            raise MerossCacheError("Unable to open shelve cache.")
        self._check_cache_version()

    def _check_cache_version(self):
        """Confirm version of the cache file."""
        with self.mutex:
            key = "__CACHE_VERSION__"
            self._shelve.setdefault(key, 1)
            if self._shelve[key] != 1:
                raise MerossCacheError("Cache file version mismatch")

    @classmethod
    def hash_auth_pair(cls, user: str, password: str) -> str:
        return hashlib.sha256(f"{user}:{password}".encode("utf8")).hexdigest()

    @classmethod
    def get_session_name_key(cls, user: str, password: str):
        hashval = cls.hash_auth_pair(user, password)
        return f"_meross_token_{hashval}"

    def get_cloud_session_token(self, user: str, password: str):
        """Returns a cloud token for user/password combination (if exists) or `None`"""
        key = self.get_session_name_key(user, password)
        with self.mutex:
            return self._shelve.get(key, None)

    def set_cloud_session_token(self, user: str, password: str, value):
        """Returns a cloud token for user/password combination (if exists) or `None`"""
        key = self.get_session_name_key(user, password)
        with self.mutex:
            self._shelve[key] = value
        return key

    def delete_cloud_session_token(self, user: str, password: str):
        key = self.get_session_name_key(user, password)
        with self.mutex:
            self._shelve.pop(key, None)


NO_VALUE = object()


class AsyncCachedObject:
    """A cached object handler.

    It discards the cached instance if:
        - the generated key is changed
        - timeout (in seconds) is reached.

    The get() function either raises an exception or returns the `default` value
    if the `enabled` callable returns false

    The value generated by `get_key()` function has to be immutable
    """

    timeout = None
    _cached_key = _cached_value = NO_VALUE
    _cache_time = 0

    def __init__(
        self,
        enabled: Callable,
        get_key: Callable,
        get_object: Callable,
        timeout: int = None,
    ):
        self.enabled = enabled
        self.get_key = get_key
        self.get_object = get_object
        self.timeout = timeout

    async def __call__(self, default=NO_VALUE):
        if not await self._call(self.enabled):
            if default is NO_VALUE:
                raise MerossCacheError("The cache is disabled")
            else:
                return default

        if await self._cache_update_needed():
            try:
                self._cached_value = await self._call(self.get_object)
            except CacheGetError as err:
                logger.error(f"Unable to get cache value: {err}.")
                self.flush()
                if default is NO_VALUE:
                    # allow the exception to bubble up
                    raise
                else:
                    return default
            else:
                if self._cached_value is not NO_VALUE:
                    self._cached_key = await self._call(self.get_key)
                    self._cache_time = time.time()

        for maybe_rv in (self._cached_value, default):
            if maybe_rv is not NO_VALUE:
                return maybe_rv
        return None  # final fallback

    def flush(self):
        """Flush cache."""
        self._cached_value = self._cached_key = NO_VALUE
        self._cache_time = 0

    def cache_key(self):
        """Non-async function whose value changes every time the cached object changes."""
        return f"{self._cached_key}_{self._cache_time}"

    async def _cache_update_needed(self):
        if self.timeout and self.timeout > 0:
            if (self._cache_time + self.timeout) < time.time():
                # Cache refresh required due to timeout
                return True
        if self._cached_key is NO_VALUE:
            # No cached key
            return True
        cur_key = await self._call(self.get_key)
        # Update is required if the current key differs from the cached copy
        return cur_key != self._cached_key

    async def _call(self, fn: Callable):
        """Asynchronously calls the `callable` if it's awaitable

        or just runs the function directly if it isn't.
        """
        out = fn()
        if inspect.isawaitable(out):
            out = await out
        return out
